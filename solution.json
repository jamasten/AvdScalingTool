{
  "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
  "contentVersion": "1.0.0.0",
  "metadata": {
    "_generator": {
      "name": "bicep",
      "version": "0.27.1.19265",
      "templateHash": "16159947942284726566"
    }
  },
  "parameters": {
    "azureBlobsPrivateDnsZoneResourceId": {
      "type": "string",
      "metadata": {
        "description": "The resource ID of the private DNS zone for Azure Blobs."
      }
    },
    "azureFilesPrivateDnsZoneResourceId": {
      "type": "string",
      "metadata": {
        "description": "The resource ID of the private DNS zone for Azure Files."
      }
    },
    "azureFunctionsPrivateDnsZoneResourceId": {
      "type": "string",
      "metadata": {
        "description": "The resource ID of the private DNS zone for Azure Functions."
      }
    },
    "azureQueuesPrivateDnsZoneResourceId": {
      "type": "string",
      "metadata": {
        "description": "The resource ID of the private DNS zone for Azure Queues."
      }
    },
    "azureTablesPrivateDnsZoneResourceId": {
      "type": "string",
      "metadata": {
        "description": "The resource ID of the private DNS zone for Azure Tables."
      }
    },
    "beginPeakTime": {
      "type": "string",
      "defaultValue": "08:00",
      "allowedValues": [
        "00:00",
        "01:00",
        "02:00",
        "03:00",
        "04:00",
        "05:00",
        "06:00",
        "07:00",
        "08:00",
        "09:00",
        "10:00",
        "11:00",
        "12:00",
        "13:00",
        "14:00",
        "15:00",
        "16:00",
        "17:00",
        "18:00",
        "19:00",
        "20:00",
        "21:00",
        "22:00",
        "23:00"
      ],
      "metadata": {
        "description": "The time of day when the peak period begins."
      }
    },
    "delegatedSubnetResourceId": {
      "type": "string",
      "metadata": {
        "description": "The resource ID of the target subnet delegated for outbound access for the function app."
      }
    },
    "endPeakTime": {
      "type": "string",
      "defaultValue": "17:00",
      "allowedValues": [
        "00:00",
        "01:00",
        "02:00",
        "03:00",
        "04:00",
        "05:00",
        "06:00",
        "07:00",
        "08:00",
        "09:00",
        "10:00",
        "11:00",
        "12:00",
        "13:00",
        "14:00",
        "15:00",
        "16:00",
        "17:00",
        "18:00",
        "19:00",
        "20:00",
        "21:00",
        "22:00",
        "23:00"
      ],
      "metadata": {
        "description": "The time of day when the peak period ends."
      }
    },
    "environmentAbbreviation": {
      "type": "string",
      "allowedValues": [
        "dev",
        "prod",
        "test"
      ],
      "metadata": {
        "description": "The abbreviation for the target environment."
      }
    },
    "hostPoolName": {
      "type": "string",
      "metadata": {
        "description": "The name of the AVD host pool."
      }
    },
    "hostPoolResourceGroupName": {
      "type": "string",
      "metadata": {
        "description": "The name of the resource group containing the AVD host pool."
      }
    },
    "identifier": {
      "type": "string",
      "maxLength": 3,
      "metadata": {
        "description": "The unique identifier between each business unit or project supporting AVD in your tenant. This is the unique naming component between each AVD stamp."
      }
    },
    "keyExpirationInDays": {
      "type": "int",
      "defaultValue": 30,
      "metadata": {
        "description": "The number days before the key expires. The key will be rotated before it expires and is used to encrypt the storage account."
      }
    },
    "keyVaultPrivateDnsZoneResourceId": {
      "type": "string",
      "metadata": {
        "description": "The resource ID of the private DNS zone for the key vault."
      }
    },
    "limitSecondsToForceLogOffUser": {
      "type": "string",
      "defaultValue": "0",
      "metadata": {
        "description": "The number of seconds to wait before forcing a user to log off. This setting should only be used if session time limits are not managed on host."
      }
    },
    "location": {
      "type": "string",
      "defaultValue": "[resourceGroup().location]",
      "metadata": {
        "description": "The target location for the deployed resources."
      }
    },
    "logAnalyticsWorkspaceResourceId": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "The resource ID of the log analytics workspace for monitoring the resources in this solution."
      }
    },
    "minimumNumberOfRdsh": {
      "type": "string",
      "defaultValue": "0",
      "metadata": {
        "description": "The minimum number of session host VMs to keep running during off-peak hours. The scaling tool will not work if all virtual machines are turned off and the Start VM On Connect solution is not enabled."
      }
    },
    "privateEndpointsSubnetResourceId": {
      "type": "string",
      "metadata": {
        "description": "The resource ID of the subnet for the private endpoints."
      }
    },
    "privateLinkScopeResourceId": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "The resource ID of the Azure Monitor Private Link Scope."
      }
    },
    "sessionHostsResourceGroupName": {
      "type": "string",
      "metadata": {
        "description": "The name of the resource group containing the AVD session hosts."
      }
    },
    "sessionThresholdPerCPU": {
      "type": "string",
      "defaultValue": "1",
      "metadata": {
        "description": "The maximum number of sessions per CPU that will be used as a threshold to determine when new session host VMs need to be started during peak hours"
      }
    },
    "tags": {
      "type": "object",
      "defaultValue": {},
      "metadata": {
        "description": "The key / value pairs of metadata for the Azure resource groups and resources."
      }
    },
    "timestamp": {
      "type": "string",
      "defaultValue": "[utcNow('yyyyMMddhhmmss')]",
      "metadata": {
        "description": "DO NOT MODIFY THIS VALUE! The timestamp is needed to differentiate deployments for certain Azure resources and must be set using a parameter."
      }
    }
  },
  "variables": {
    "$fxv#0": {
      "AzureChina": {
        "chinaeast": {
          "abbreviation": "cne",
          "recoveryServicesGeo": "sha",
          "timeDifference": "+8:00",
          "timeZone": "China Standard Time"
        },
        "chinaeast2": {
          "abbreviation": "cne2",
          "recoveryServicesGeo": "sha2",
          "timeDifference": "+8:00",
          "timeZone": "China Standard Time"
        },
        "chinanorth": {
          "abbreviation": "cnn",
          "recoveryServicesGeo": "bjb",
          "timeDifference": "+8:00",
          "timeZone": "China Standard Time"
        },
        "chinanorth2": {
          "abbreviation": "cnn2",
          "recoveryServicesGeo": "bjb2",
          "timeDifference": "+8:00",
          "timeZone": "China Standard Time"
        }
      },
      "AzureCloud": {
        "australiacentral": {
          "abbreviation": "auc",
          "recoveryServicesGeo": "acl",
          "timeDifference": "+10:00",
          "timeZone": "AUS Eastern Standard Time"
        },
        "australiacentral2": {
          "abbreviation": "auc2",
          "recoveryServicesGeo": "acl2",
          "timeDifference": "+10:00",
          "timeZone": "AUS Eastern Standard Time"
        },
        "australiaeast": {
          "abbreviation": "aue",
          "recoveryServicesGeo": "ae",
          "timeDifference": "+10:00",
          "timeZone": "AUS Eastern Standard Time"
        },
        "australiasoutheast": {
          "abbreviation": "ause",
          "recoveryServicesGeo": "ase",
          "timeDifference": "+10:00",
          "timeZone": "AUS Eastern Standard Time"
        },
        "brazilsouth": {
          "abbreviation": "brs",
          "recoveryServicesGeo": "brs",
          "timeDifference": "-3:00",
          "timeZone": "E. South America Standard Time"
        },
        "brazilsoutheast": {
          "abbreviation": "brse",
          "recoveryServicesGeo": "bse",
          "timeDifference": "-3:00",
          "timeZone": "E. South America Standard Time"
        },
        "canadacentral": {
          "abbreviation": "cac",
          "recoveryServicesGeo": "cnc",
          "timeDifference": "-5:00",
          "timeZone": "Eastern Standard Time"
        },
        "canadaeast": {
          "abbreviation": "cae",
          "recoveryServicesGeo": "cne",
          "timeDifference": "-5:00",
          "timeZone": "Eastern Standard Time"
        },
        "centralindia": {
          "abbreviation": "inc",
          "recoveryServicesGeo": "inc",
          "timeDifference": "+5:30",
          "timeZone": "India Standard Time"
        },
        "centralus": {
          "abbreviation": "usc",
          "recoveryServicesGeo": "cus",
          "timeDifference": "-6:00",
          "timeZone": "Central Standard Time"
        },
        "eastasia": {
          "abbreviation": "ase",
          "recoveryServicesGeo": "ea",
          "timeDifference": "+8:00",
          "timeZone": "China Standard Time"
        },
        "eastus": {
          "abbreviation": "use",
          "recoveryServicesGeo": "eus",
          "timeDifference": "-5:00",
          "timeZone": "Eastern Standard Time"
        },
        "eastus2": {
          "abbreviation": "use2",
          "recoveryServicesGeo": "eus2",
          "timeDifference": "-5:00",
          "timeZone": "Eastern Standard Time"
        },
        "francecentral": {
          "abbreviation": "frc",
          "recoveryServicesGeo": "frc",
          "timeDifference": "+1:00",
          "timeZone": "Central Europe Standard Time"
        },
        "francesouth": {
          "abbreviation": "frs",
          "recoveryServicesGeo": "frs",
          "timeDifference": "+1:00",
          "timeZone": "Central Europe Standard Time"
        },
        "germanynorth": {
          "abbreviation": "den",
          "recoveryServicesGeo": "gn",
          "timeDifference": "+1:00",
          "timeZone": "Central Europe Standard Time"
        },
        "germanywestcentral": {
          "abbreviation": "dewc",
          "recoveryServicesGeo": "gwc",
          "timeDifference": "+1:00",
          "timeZone": "Central Europe Standard Time"
        },
        "israelcentral": {
          "abbreviation": "ilc",
          "recoveryServicesGeo": "ilc",
          "timeDifference": "+2:00",
          "timeZone": "Israel Standard Time"
        },
        "italynorth": {
          "abbreviation": "itn",
          "recoveryServicesGeo": "itn",
          "timeDifference": "+1:00",
          "timeZone": "Central Europe Standard Time"
        },
        "japaneast": {
          "abbreviation": "jpe",
          "recoveryServicesGeo": "jpe",
          "timeDifference": "+9:00",
          "timeZone": "Tokyo Standard Time"
        },
        "japanwest": {
          "abbreviation": "jpw",
          "recoveryServicesGeo": "jpw",
          "timeDifference": "+9:00",
          "timeZone": "Tokyo Standard Time"
        },
        "jioindiacentral": {
          "abbreviation": "injc",
          "recoveryServicesGeo": "jic",
          "timeDifference": "+5:30",
          "timeZone": "India Standard Time"
        },
        "jioindiawest": {
          "abbreviation": "injw",
          "recoveryServicesGeo": "jiw",
          "timeDifference": "+5:30",
          "timeZone": "India Standard Time"
        },
        "koreacentral": {
          "abbreviation": "krc",
          "recoveryServicesGeo": "krc",
          "timeDifference": "+9:00",
          "timeZone": "Korea Standard Time"
        },
        "koreasouth": {
          "abbreviation": "krs",
          "recoveryServicesGeo": "krs",
          "timeDifference": "+9:00",
          "timeZone": "Korea Standard Time"
        },
        "northcentralus": {
          "abbreviation": "usnc",
          "recoveryServicesGeo": "ncus",
          "timeDifference": "-6:00",
          "timeZone": "Central Standard Time"
        },
        "northeurope": {
          "abbreviation": "eun",
          "recoveryServicesGeo": "ne",
          "timeDifference": "0:00",
          "timeZone": "GMT Standard Time"
        },
        "norwayeast": {
          "abbreviation": "noe",
          "recoveryServicesGeo": "nwe",
          "timeDifference": "+1:00",
          "timeZone": "Central Europe Standard Time"
        },
        "norwaywest": {
          "abbreviation": "now",
          "recoveryServicesGeo": "nww",
          "timeDifference": "+1:00",
          "timeZone": "Central Europe Standard Time"
        },
        "polandcentral": {
          "abbreviation": "plc",
          "recoveryServicesGeo": "plc",
          "timeDifference": "+1:00",
          "timeZone": "Central Europe Standard Time"
        },
        "qatarcentral": {
          "abbreviation": "qac",
          "recoveryServicesGeo": "qac",
          "timeDifference": "+3:00",
          "timeZone": "Arabian Standard Time"
        },
        "southafricanorth": {
          "abbreviation": "zan",
          "recoveryServicesGeo": "san",
          "timeDifference": "+2:00",
          "timeZone": "South Africa Standard Time"
        },
        "southafricawest": {
          "abbreviation": "zaw",
          "recoveryServicesGeo": "saw",
          "timeDifference": "+2:00",
          "timeZone": "South Africa Standard Time"
        },
        "southcentralus": {
          "abbreviation": "ussc",
          "recoveryServicesGeo": "scus",
          "timeDifference": "-6:00",
          "timeZone": "Central Standard Time"
        },
        "southeastasia": {
          "abbreviation": "asse",
          "recoveryServicesGeo": "sea",
          "timeDifference": "+8:00",
          "timeZone": "Singapore Standard Time"
        },
        "southindia": {
          "abbreviation": "ins",
          "recoveryServicesGeo": "ins",
          "timeDifference": "+5:30",
          "timeZone": "India Standard Time"
        },
        "swedencentral": {
          "abbreviation": "sec",
          "recoveryServicesGeo": "sdc",
          "timeDifference": "+1:00",
          "timeZone": "Central Europe Standard Time"
        },
        "switzerlandnorth": {
          "abbreviation": "chn",
          "recoveryServicesGeo": "szn",
          "timeDifference": "+1:00",
          "timeZone": "Central Europe Standard Time"
        },
        "switzerlandwest": {
          "abbreviation": "chw",
          "recoveryServicesGeo": "szw",
          "timeDifference": "+1:00",
          "timeZone": "Central Europe Standard Time"
        },
        "uaecentral": {
          "abbreviation": "aec",
          "recoveryServicesGeo": "uac",
          "timeDifference": "+3:00",
          "timeZone": "Arabian Standard Time"
        },
        "uaenorth": {
          "abbreviation": "aen",
          "recoveryServicesGeo": "uan",
          "timeDifference": "+3:00",
          "timeZone": "Arabian Standard Time"
        },
        "uksouth": {
          "abbreviation": "uks",
          "recoveryServicesGeo": "uks",
          "timeDifference": "0:00",
          "timeZone": "GMT Standard Time"
        },
        "ukwest": {
          "abbreviation": "ukw",
          "recoveryServicesGeo": "ukw",
          "timeDifference": "0:00",
          "timeZone": "GMT Standard Time"
        },
        "westcentralus": {
          "abbreviation": "uswc",
          "recoveryServicesGeo": "wcus",
          "timeDifference": "-7:00",
          "timeZone": "Mountain Standard Time"
        },
        "westeurope": {
          "abbreviation": "euw",
          "recoveryServicesGeo": "we",
          "timeDifference": "+1:00",
          "timeZone": "Central Europe Standard Time"
        },
        "westindia": {
          "abbreviation": "inw",
          "recoveryServicesGeo": "inw",
          "timeDifference": "+5:30",
          "timeZone": "India Standard Time"
        },
        "westus": {
          "abbreviation": "usw",
          "recoveryServicesGeo": "wus",
          "timeDifference": "-8:00",
          "timeZone": "Pacific Standard Time"
        },
        "westus2": {
          "abbreviation": "usw2",
          "recoveryServicesGeo": "wus2",
          "timeDifference": "-8:00",
          "timeZone": "Pacific Standard Time"
        },
        "westus3": {
          "abbreviation": "usw3",
          "recoveryServicesGeo": "wus3",
          "timeDifference": "-7:00",
          "timeZone": "Mountain Standard Time"
        }
      },
      "AzureUSGovernment": {
        "usdodcentral": {
          "abbreviation": "dodc",
          "recoveryServicesGeo": "udc",
          "timeDifference": "-6:00",
          "timeZone": "Central Standard Time"
        },
        "usdodeast": {
          "abbreviation": "dode",
          "recoveryServicesGeo": "ude",
          "timeDifference": "-5:00",
          "timeZone": "Eastern Standard Time"
        },
        "usgovarizona": {
          "abbreviation": "az",
          "recoveryServicesGeo": "uga",
          "timeDifference": "-7:00",
          "timeZone": "Mountain Standard Time"
        },
        "usgovtexas": {
          "abbreviation": "tx",
          "recoveryServicesGeo": "ugt",
          "timeDifference": "-6:00",
          "timeZone": "Central Standard Time"
        },
        "usgovvirginia": {
          "abbreviation": "va",
          "recoveryServicesGeo": "ugv",
          "timeDifference": "-5:00",
          "timeZone": "Eastern Standard Time"
        }
      },
      "USNat": {
        "usnateast": {
          "abbreviation": "east",
          "recoveryServicesGeo": "exe",
          "timeDifference": "-5:00",
          "timeZone": "Eastern Standard Time"
        },
        "usnatwest": {
          "abbreviation": "west",
          "recoveryServicesGeo": "exw",
          "timeDifference": "-8:00",
          "timeZone": "Pacific Standard Time"
        }
      },
      "USSec": {
        "usseceast": {
          "abbreviation": "east",
          "recoveryServicesGeo": "rxe",
          "timeDifference": "-5:00",
          "timeZone": "Eastern Standard Time"
        },
        "ussecwest": {
          "abbreviation": "west",
          "recoveryServicesGeo": "rxw",
          "timeDifference": "-8:00",
          "timeZone": "Pacific Standard Time"
        }
      }
    },
    "$fxv#1": {
      "actionGroups": "ag",
      "applicationInsights": "appi",
      "appServicePlans": "asp",
      "diagnosticSettings": "diag",
      "functionApps": "fa",
      "functions": "func",
      "keyVaults": "kv",
      "networkInterfaces": "nic",
      "privateEndpoints": "pe",
      "smartDetectorAlertRules": "sdar",
      "storageAccounts": "st",
      "userAssignedIdentities": "uami"
    },
    "$fxv#2": "# This file enables modules to be automatically managed by the Functions service.\r\n# See https://aka.ms/functionsmanageddependency for additional information.\r\n#\r\n@{\r\n    # For latest supported version, go to 'https://www.powershellgallery.com/packages/Az'. \r\n    # To use the Az module in your function app, please uncomment the line below.\r\n    # 'Az' = '7.*'\r\n}",
    "$fxv#3": "param($Timer)\r\n\r\ntry\r\n{\r\n\t[string]$BeginPeakTime = $env:BeginPeakTime\r\n\t[string]$EndPeakTime = $env:EndPeakTime\r\n\t[string]$EnvironmentName = $env:EnvironmentName\r\n\t[string]$HostPoolName = $env:HostPoolName\r\n\t[string]$HostPoolResourceGroupName = $env:HostPoolResourceGroupName\r\n\t[int]$LimitSecondsToForceLogOffUser = $env:LimitSecondsToForceLogOffUser\r\n\t[string]$LogOffMessageBody = $env:LogOffMessageBody\r\n\t[string]$LogOffMessageTitle = $env:LogOffMessageTitle\r\n\t[string]$MaintenanceTagName = $env:MaintenanceTagName\r\n\t[int]$MinimumNumberOfRDSH = $env:MinimumNumberOfRDSH\r\n\t[string]$ResourceManagerUrl = $env:ResourceManagerUrl\r\n\t[double]$SessionThresholdPerCPU = $env:SessionThresholdPerCPU\r\n\t[string]$SubscriptionId = $env:SubscriptionId\r\n\t[string]$TenantId = $env:TenantId\r\n\t[string]$TimeDifference = $env:TimeDifference\r\n\t[string[]]$DesiredRunningStates = @('Available', 'NeedsAssistance')\r\n\t[string[]]$TimeDiffHrsMin = \"$($TimeDifference):0\".Split(':')\r\n\r\n\r\n\t#region Functions\r\n\tfunction Get-LocalDateTime\r\n    {\r\n\t\treturn (Get-Date).ToUniversalTime().AddHours($TimeDiffHrsMin[0]).AddMinutes($TimeDiffHrsMin[1])\r\n\t}\r\n\r\n\tfunction Write-Log \r\n    {\r\n\t\t[CmdletBinding()]\r\n\t\tparam (\r\n\t\t\t[Parameter(Mandatory = $false)]\r\n\t\t\t[switch]$Err,\r\n\r\n\t\t\t[Parameter(Mandatory = $true)]\r\n\t\t\t[string]$HostPoolName,\r\n\r\n\t\t\t[Parameter(Mandatory = $true)]\r\n\t\t\t[string]$Message,\r\n\r\n\t\t\t[Parameter(Mandatory = $false)]\r\n\t\t\t[switch]$Warn\r\n\t\t)\r\n\r\n\t\t[string]$MessageTimeStamp = (Get-LocalDateTime).ToString('yyyy-MM-dd HH:mm:ss')\r\n\t\t$Message = \"[$($MyInvocation.ScriptLineNumber)] [$($HostPoolName)] $Message\"\r\n\t\t[string]$WriteMessage = \"[$($MessageTimeStamp)] $Message\"\r\n\r\n\t\tif ($Err)\r\n        {\r\n\t\t\tWrite-Error $WriteMessage\r\n\t\t\t$Message = \"ERROR: $Message\"\r\n\t\t}\r\n\t\telseif ($Warn)\r\n        {\r\n\t\t\tWrite-Warning $WriteMessage\r\n\t\t\t$Message = \"WARN: $Message\"\r\n\t\t}\r\n\t\telse \r\n        {\r\n\t\t\tWrite-Output $WriteMessage\r\n\t\t}\r\n\t}\r\n\r\n\tfunction Set-nVMsToStartOrStop \r\n    {\r\n\t\tparam (\r\n\t\t\t[Parameter(Mandatory = $true)]\r\n\t\t\t[string]$HostPoolName,\r\n\r\n\t\t\t[Parameter(Mandatory = $false)]\r\n\t\t\t[switch]$InPeakHours,\r\n\r\n\t\t\t[Parameter(Mandatory = $true)]\r\n\t\t\t[int]$MaxUserSessionsPerVM,\r\n\t\t\r\n\t\t\t[Parameter(Mandatory = $true)]\r\n\t\t\t[int]$nRunningCores,\r\n\r\n\t\t\t[Parameter(Mandatory = $true)]\r\n\t\t\t[int]$nRunningVMs,\r\n\t\t\t\r\n\t\t\t[Parameter(Mandatory = $true)]\r\n\t\t\t[int]$nUserSessions,\r\n\r\n\t\t\t[Parameter(Mandatory = $true)]\r\n\t\t\t[hashtable]$Res\r\n\t\t)\r\n\r\n\t\t# check if need to adjust min num of running session hosts required if the number of user sessions is close to the max allowed by the min num of running session hosts required\r\n\t\t[double]$MaxUserSessionsThreshold = 0.9\r\n\t\t[int]$MaxUserSessionsThresholdCapacity = [math]::Floor($MinimumNumberOfRDSH * $MaxUserSessionsPerVM * $MaxUserSessionsThreshold)\r\n\t\tif ($nUserSessions -gt $MaxUserSessionsThresholdCapacity)\r\n        {\r\n\t\t\t$MinimumNumberOfRDSH = [math]::Ceiling($nUserSessions / ($MaxUserSessionsPerVM * $MaxUserSessionsThreshold))\r\n\t\t\tWrite-Log -HostPoolName $HostPoolName -Message \"Number of user sessions is more than $($MaxUserSessionsThreshold * 100) % of the max number of sessions allowed with minimum number of running session hosts required ($MaxUserSessionsThresholdCapacity). Adjusted minimum number of running session hosts required to $MinimumNumberOfRDSH\"\r\n\t\t}\r\n\r\n\t\t# Check if minimum number of session hosts are running\r\n\t\tif ($nRunningVMs -lt $MinimumNumberOfRDSH)\r\n        {\r\n\t\t\t$res.nVMsToStart = $MinimumNumberOfRDSH - $nRunningVMs\r\n\t\t\tWrite-Log -HostPoolName $HostPoolName -Message \"Number of running session host is less than minimum required. Need to start $($res.nVMsToStart) VMs\"\r\n\t\t}\r\n\t\t\r\n\t\tif ($InPeakHours)\r\n        {\r\n\t\t\t[double]$nUserSessionsPerCore = $nUserSessions / $nRunningCores\r\n\t\t\t# In peak hours: check if current capacity is meeting the user demands\r\n\t\t\tif ($nUserSessionsPerCore -gt $SessionThresholdPerCPU)\r\n            {\r\n\t\t\t\t$res.nCoresToStart = [math]::Ceiling(($nUserSessions / $SessionThresholdPerCPU) - $nRunningCores)\r\n\t\t\t\tWrite-Log -HostPoolName $HostPoolName -Message \"[In peak hours] Number of user sessions per Core is more than the threshold. Need to start $($res.nCoresToStart) cores\"\r\n\t\t\t}\r\n\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tif ($nRunningVMs -gt $MinimumNumberOfRDSH)\r\n        {\r\n\t\t\t# Calculate the number of session hosts to stop\r\n\t\t\t$res.nVMsToStop = $nRunningVMs - $MinimumNumberOfRDSH\r\n\t\t\tWrite-Log -HostPoolName $HostPoolName -Message \"[Off peak hours] Number of running session host is greater than minimum required. Need to stop $($res.nVMsToStop) VMs\"\r\n\t\t}\r\n\t}\r\n\r\n\tfunction TryUpdateSessionHostDrainMode\r\n    {\r\n\t\t[CmdletBinding()]\r\n\t\tparam (\r\n\t\t\t[Parameter(Mandatory = $true)]\r\n\t\t\t[bool]$AllowNewSession,\r\n\r\n\t\t\t[Parameter(Mandatory = $true)]\r\n\t\t\t[hashtable]$Header,\r\n\r\n\t\t\t[Parameter(Mandatory = $true)]\r\n\t\t\t[string]$HostPoolName,\r\n\r\n\t\t\t[Parameter(Mandatory = $true)]\r\n\t\t\t[string]$HostPoolResourceGroupName,\r\n\r\n\t\t\t[Parameter(Mandatory = $true)]\r\n\t\t\t[string]$ResourceManagerUrl,\r\n\r\n\t\t\t[Parameter(Mandatory = $true)]\r\n\t\t\t[string]$SessionHostName,\r\n\r\n\t\t\t[Parameter(Mandatory = $true)]\r\n\t\t\t[string]$SubscriptionId\r\n\t\t)\r\n\t\tBegin { }\r\n\t\tProcess \r\n        {\r\n\t\t\tWrite-Log -HostPoolName $HostPoolName -Message \"Update session host '$SessionHostName' to set allow new sessions to $AllowNewSession\"\r\n\t\t\ttry \r\n\t\t\t{\r\n\t\t\t\t$Uri = $ResourceManagerUrl + 'subscriptions/' + $SubscriptionId  + '/resourceGroups/' + $HostPoolResourceGroupName + '/providers/Microsoft.DesktopVirtualization/hostPools/' + $HostPoolName + '/sessionHosts/' + $SessionHostName + '?api-version=2022-02-10-preview'\r\n\t\t\t\tInvoke-RestMethod -Headers $Header -Body (@{properties = @{allowNewSession = $AllowNewSession}} | ConvertTo-Json) -Method 'Patch' -Uri $Uri | Out-Null\r\n\t\t\t}\r\n\t\t\tcatch\r\n\t\t\t{\r\n\t\t\t\tWrite-Log -HostPoolName $HostPoolName -Warn -Message \"Failed to update the session host '$SessionHostName' to set allow new sessions to $($AllowNewSession): $($PSItem | Format-List -Force | Out-String)\"\r\n\t\t\t}\r\n\t\t}\r\n\t\tEnd { }\r\n\t}\r\n\r\n\tfunction TryForceLogOffUser\r\n    {\r\n\t\t[CmdletBinding()]\r\n\t\tparam (\r\n\t\t\t[Parameter(Mandatory = $true)]\r\n\t\t\t[hashtable]$Header,\r\n\r\n\t\t\t[Parameter(Mandatory = $true)]\r\n\t\t\t[string]$HostPoolName,\r\n\r\n\t\t\t[Parameter(Mandatory = $true)]\r\n\t\t\t[string]$HostPoolResourceGroupName,\r\n\r\n\t\t\t[Parameter(Mandatory = $true)]\r\n\t\t\t[string]$ResourceManagerUrl,\r\n\r\n\t\t\t[Parameter(Mandatory = $true, ValueFromPipeline = $true)]\r\n\t\t\t$Session,\r\n\r\n\t\t\t[Parameter(Mandatory = $true)]\r\n\t\t\t[string]$SubscriptionId\r\n\t\t)\r\n\t\tBegin { }\r\n\t\tProcess\r\n        {\r\n            [string[]]$Toks = $Session.Name.Split('/')\r\n            [string]$SessionHostName = $Toks[1]\r\n            [string]$SessionID = $Toks[-1]\r\n            [string]$User = $Session.ActiveDirectoryUserName\r\n\r\n\t\t\ttry \r\n\t\t\t{\r\n\t\t\t\tWrite-Log -HostPoolName $HostPoolName -Message \"Force log off user: '$User', session ID: $SessionID\"\r\n\r\n\t\t\t\t$Uri = $ResourceManagerUrl + 'subscriptions/' + $SubscriptionId  + '/resourceGroups/' + $HostPoolResourceGroupName + '/providers/Microsoft.DesktopVirtualization/hostPools/' + $HostPoolName + '/sessionHosts/' + $SessionHostName + '/userSessions/' + $SessionID + '?api-version=2022-02-10-preview&force=True'\r\n\t\t\t\tInvoke-RestMethod -Headers $Header -Method 'Delete' -Uri $Uri | Out-Null\r\n\t\t\t}\r\n\t\t\tcatch \r\n\t\t\t{\r\n\t\t\t\tWrite-Log -HostPoolName $HostPoolName -Warn -Message \"Failed to force log off user: '$User', session ID: $SessionID $($PSItem | Format-List -Force | Out-String)\"\r\n\t\t\t}\r\n\t\t}\r\n\t\tEnd { }\r\n\t}\r\n\r\n\tfunction TryResetSessionHostDrainModeAndUserSessions\r\n    {\r\n\t\t[CmdletBinding()]\r\n\t\tparam (\r\n\t\t\t[Parameter(Mandatory = $true)]\r\n\t\t\t[hashtable]$Header,\r\n\r\n\t\t\t[Parameter(Mandatory = $true)]\r\n\t\t\t[string]$HostPoolName,\r\n\r\n\t\t\t[Parameter(Mandatory = $true)]\r\n\t\t\t[string]$HostPoolResourceGroupName,\r\n\r\n\t\t\t[Parameter(Mandatory = $true)]\r\n\t\t\t[string]$ResourceManagerUrl,\r\n\r\n\t\t\t[Parameter(Mandatory = $true)]\r\n\t\t\t[string]$SessionHostName,\r\n\r\n\t\t\t[Parameter(Mandatory = $true)]\r\n\t\t\t[int]$SessionHostSessions,\r\n\r\n\t\t\t[Parameter(Mandatory = $true)]\r\n\t\t\t[string]$SubscriptionId\r\n\t\t)\r\n\t\tBegin { }\r\n\t\tProcess \r\n        {\r\n\t\t\tTryUpdateSessionHostDrainMode -AllowNewSession $true -Header $Header -HostPoolName $HostPoolName -HostPoolResourceGroupName $HostPoolResourceGroupName -ResourceManagerUrl $ResourceManagerUrl -SessionHostName $SessionHostName -SubscriptionId $SubscriptionId\r\n\r\n\t\t\tif ($SessionHostSessions -eq 0)\r\n            {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\r\n\t\t\tWrite-Log -HostPoolName $HostPoolName -Warn -Message \"Session host '$SessionHostName' still has $SessionHostSessions) sessions left behind in broker DB\"\r\n\r\n\t\t\tWrite-Log -HostPoolName $HostPoolName -Message \"Get all user sessions from session host '$SessionHostName'\"\r\n\t\t\ttry \r\n\t\t\t{\r\n\t\t\t\t$Uri = $ResourceManagerUrl + 'subscriptions/' + $SubscriptionId  + '/resourceGroups/' + $HostPoolResourceGroupName + '/providers/Microsoft.DesktopVirtualization/hostPools/' + $HostPoolName + '/sessionHosts/' + $SessionHostName + '/userSessions?api-version=2022-02-10-preview'\r\n\t\t\t\t$UserSessions = Invoke-RestMethod -Headers $Header -Method 'Get' -Uri $Uri\r\n\t\t\t}\r\n\t\t\tcatch \r\n\t\t\t{\r\n\t\t\t\tWrite-Log -HostPoolName $HostPoolName -Warn -Message \"Failed to retrieve user sessions of session host '$SessionHostName': $($PSItem | Format-List -Force | Out-String)\"\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\r\n\t\t\tWrite-Log -HostPoolName $HostPoolName -Message \"Force log off $($UserSessions.Count) users on session host: '$SessionHostName'\"\r\n\t\t\t$UserSessions | TryForceLogOffUser -Header $Header -HostPoolName $HostPoolName -HostPoolResourceGroupName $HostPoolResourceGroupName -ResourceManagerUrl $ResourceManagerUrl -SubscriptionId $SubscriptionId\r\n\t\t}\r\n\t\tEnd { }\r\n\t}\r\n\t#endregion Functions\r\n\r\n\r\n\t# Note: https://stackoverflow.com/questions/41674518/powershell-setting-security-protocol-to-tls-1-2\r\n\t[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\r\n\r\n\r\n\t#region Azure Authentication\r\n    $AccessToken = $null\r\n    try\r\n    {\r\n\t\t$TokenAuthURI = $env:IDENTITY_ENDPOINT + '?resource=' + $ResourceManagerUrl + '&api-version=2019-08-01'\r\n\t\t$TokenResponse = Invoke-RestMethod -Method Get -Headers @{\"X-IDENTITY-HEADER\"=\"$env:IDENTITY_HEADER\"} -Uri $TokenAuthURI\r\n\t\t$AccessToken = $TokenResponse.access_token\r\n\t\t$Header = @{\r\n\t\t\t'Content-Type'='application/json'\r\n\t\t\t'Authorization'='Bearer ' + $AccessToken\r\n\t\t}\r\n    }\r\n    catch\r\n    {\r\n        throw [System.Exception]::new('Failed to authenticate Azure with application ID, tenant ID, subscription ID', $PSItem.Exception)\r\n    }\r\n    Write-Log -HostPoolName $HostPoolName -Message \"Successfully authenticated with Azure using a managed identity\"\r\n\t#endregion Azure Authentication\r\n\r\n\r\n\t#region validate host pool, validate / update HostPool load balancer type, ensure there is at least 1 session host, get num of user sessions\r\n\t# Validate and get host pool info\r\n\t$HostPool = $null\r\n\ttry \r\n\t{\r\n\t\tWrite-Log -HostPoolName $HostPoolName -Message \"Get host pool information\"\r\n\t\t$Uri = $ResourceManagerUrl + 'subscriptions/' + $SubscriptionId  + '/resourceGroups/' + $HostPoolResourceGroupName + '/providers/Microsoft.DesktopVirtualization/hostPools/' + $HostPoolName + '?api-version=2022-02-10-preview'\r\n\t\t$HostPool = Invoke-RestMethod -Headers $Header -Method 'Get' -Uri $Uri\r\n\r\n\t\tif (!$HostPool) \r\n\t\t{\r\n\t\t\tthrow $HostPool\r\n\t\t}\r\n\t}\r\n\tcatch \r\n\t{\r\n\t\tthrow [System.Exception]::new(\"Failed to get host pool info of '$HostPoolName' in resource group '$HostPoolResourceGroupName'. Ensure that you have entered the correct values\", $PSItem.Exception)\r\n\t}\r\n\r\n\t# Ensure HostPool load balancer type is not persistent\r\n\tif ($HostPool.properties.loadBalancerType -ieq 'Persistent')\r\n    {\r\n\t\tthrow \"HostPool '$HostPoolName' is configured with 'Persistent' load balancer type. Scaling tool only supports these load balancer types: BreadthFirst, DepthFirst\"\r\n\t}\r\n\r\n\tWrite-Log -HostPoolName $HostPoolName -Message 'Get session hosts'\r\n\t$Uri = $ResourceManagerUrl + 'subscriptions/' + $SubscriptionId  + '/resourceGroups/' + $HostPoolResourceGroupName + '/providers/Microsoft.DesktopVirtualization/hostPools/' + $HostPoolName + '/sessionHosts?api-version=2022-02-10-preview'\r\n\t$SessionHosts = (Invoke-RestMethod -Headers $Header -Method 'Get' -Uri $Uri).value\r\n\r\n\tif (!$SessionHosts)\r\n    {\r\n\t\tWrite-Log -HostPoolName $HostPoolName -Message \"There are no session hosts in the host pool '$HostPoolName'. Ensure that hostpool has session hosts\"\r\n\t\tWrite-Log -HostPoolName $HostPoolName -Message 'End'\r\n\t\treturn\r\n\t}\r\n\r\n\tWrite-Log -HostPoolName $HostPoolName -Message 'Get number of user sessions in host pool'\r\n\t$Uri = $ResourceManagerUrl + 'subscriptions/' + $SubscriptionId  + '/resourceGroups/' + $HostPoolResourceGroupName + '/providers/Microsoft.DesktopVirtualization/hostPools/' + $HostPoolName + '/userSessions?api-version=2022-02-10-preview'\r\n\t[int]$nUserSessions = (Invoke-RestMethod -Headers $Header -Method 'Get' -Uri $Uri).value.Count\r\n\r\n\t# Set up breadth 1st load balacing type\r\n\t# Note: breadth 1st is enforced on AND off peak hours to simplify the things with scaling in the start/end of peak hours\r\n\tif (!$SkipUpdateLoadBalancerType -and $HostPool.properties.loadBalancerType -ine 'BreadthFirst')\r\n    {\r\n\t\tWrite-Log -HostPoolName $HostPoolName -Message \"Update HostPool with 'BreadthFirst' load balancer type (current: '$($HostPool.properties.loadBalancerType)')\"\r\n\r\n\t\t$Body = @{\r\n\t\t\tproperties = @{\r\n\t\t\t\tloadBalancerType = 'BreadthFirst'\r\n\t\t\t}\r\n\t\t}\r\n\t\t$Uri = $ResourceManagerUrl + 'subscriptions/' + $SubscriptionId  + '/resourceGroups/' + $HostPoolResourceGroupName + '/providers/Microsoft.DesktopVirtualization/hostPools/' + $HostPoolName + '?api-version=2022-02-10-preview'\r\n\t\t$HostPool = Invoke-RestMethod -Headers $Header -Body $Body -Method 'Patch' -Uri $Uri\r\n\t}\r\n\tWrite-Log -HostPoolName $HostPoolName -Message \"Number of session hosts in the HostPool: $($SessionHosts.Count)\"\r\n\t#endregion\r\n\t\r\n\r\n\t# region Peak Hours #\r\n\t# Convert local time, begin peak time & end peak time from UTC to local time\r\n\t$CurrentDateTime = Get-LocalDateTime\r\n\t$BeginPeakDateTime = [datetime]::Parse($CurrentDateTime.ToShortDateString() + ' ' + $BeginPeakTime)\r\n\t$EndPeakDateTime = [datetime]::Parse($CurrentDateTime.ToShortDateString() + ' ' + $EndPeakTime)\r\n\r\n\t# Adjust peak times to make sure begin peak time is always before end peak time\r\n\tif ($EndPeakDateTime -lt $BeginPeakDateTime)\r\n    {\r\n\t\tif ($CurrentDateTime -lt $EndPeakDateTime)\r\n        {\r\n\t\t\t$BeginPeakDateTime = $BeginPeakDateTime.AddDays(-1)\r\n\t\t}\r\n\t\telse\r\n        {\r\n\t\t\t$EndPeakDateTime = $EndPeakDateTime.AddDays(1)\r\n\t\t}\r\n\t}\r\n\r\n\tWrite-Log -HostPoolName $HostPoolName -Message \"Using current time: $($CurrentDateTime.ToString('yyyy-MM-dd HH:mm:ss')), begin peak time: $($BeginPeakDateTime.ToString('yyyy-MM-dd HH:mm:ss')), end peak time: $($EndPeakDateTime.ToString('yyyy-MM-dd HH:mm:ss'))\"\r\n\r\n\t[bool]$InPeakHours = ($BeginPeakDateTime -le $CurrentDateTime -and $CurrentDateTime -le $EndPeakDateTime)\r\n\tif ($InPeakHours)\r\n    {\r\n\t\tWrite-Log -HostPoolName $HostPoolName -Message 'In peak hours'\r\n\t}\r\n\telse\r\n    {\r\n\t\tWrite-Log -HostPoolName $HostPoolName -Message 'Off peak hours'\r\n\t}\r\n\t# endregion Peak Hours #\r\n\r\n\r\n\t#region get session hosts, VMs & user sessions info and compute workload\r\n\t# Note: session host is considered \"running\" if its running AND is in desired states AND allowing new sessions\r\n\t# Number of session hosts that are running, are in desired states and allowing new sessions\r\n\t[int]$nRunningVMs = 0\r\n\t# Number of cores that are running, are in desired states and allowing new sessions\r\n\t[int]$nRunningCores = 0\r\n\t# Array that contains all the virtual machine objects that are session hosts except the ones that are tagged for maintenance\r\n\t$VMs = @()\r\n\t# Object that contains the number of cores for each VM size SKU\r\n\t$VMSizeCores = @{}\r\n\t# Number of user sessions reported by each session host that is running, is in desired state and allowing new sessions\r\n\t[int]$nUserSessionsFromAllRunningVMs = 0\r\n\r\n\t# Populate all session hosts objects\r\n\tforeach ($SessionHost in $SessionHosts)\r\n    {\r\n\t\t[string]$VirtualMachineResourceId = $SessionHost.properties.resourceId\r\n\t\t[string]$VirtualMachineName = $VirtualMachineResourceId.Split('/')[8]\r\n\t\t[string]$VirtualMachineResourceGroupName = $VirtualMachineResourceId.Split('/')[4]\r\n\t\t$Uri = $ResourceManagerUrl + 'subscriptions/' + $SubscriptionId  + '/resourceGroups/' + $VirtualMachineResourceGroupName + '/providers/Microsoft.Compute/virtualMachines/' + $VirtualMachineName + '?api-version=2024-03-01&$expand=instanceView'\r\n\t\t$VirtualMachine = Invoke-RestMethod -Headers $Header -Method 'Get' -Uri $Uri\r\n\r\n\t\t# Throw an error if the virtual machine for the session host does not exist\r\n\t\tif ($VirtualMachine.error)\r\n\t\t{\r\n\t\t\tthrow \"The virtual machine for session host '$VirtualMachineName' does not exist\"\r\n\t\t}\r\n\t\t# Ignore session hosts tagged for maintenance or missing virtual machine\r\n\t\telseif($VirtualMachine.tags.Keys -contains $MaintenanceTagName)\r\n        {\r\n\t\t\tWrite-Log -HostPoolName $HostPoolName -Message \"VM '$VirtualMachineName' is in maintenance and will be ignored\"\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\telse \r\n\t\t{\r\n\t\t\t$VMs += $VirtualMachine\r\n\t\t}\r\n\r\n\t\t$PowerState = $VirtualMachine.properties.instanceView.statuses[1].displayStatus\r\n\t\tWrite-Log -HostPoolName $HostPoolName -Message \"Session host: '$($VirtualMachineName)', power state: '$PowerState', status: '$($SessionHost.properties.status)', update state: '$($SessionHost.properties.updateState)', sessions: $($SessionHost.properties.sessions), allow new session: $($SessionHost.properties.allowNewSession)\"\r\n\t\t\r\n\t\t# Get the number of cores for VM size SKU\r\n\t\tif (!$VMSizeCores.ContainsKey($VirtualMachine.properties.hardwareProfile.vmSize))\r\n        {\r\n\t\t\tWrite-Log -HostPoolName $HostPoolName -Message \"Get VM sizes in $($VirtualMachine.location)\"\r\n\r\n\t\t\t$Uri = $ResourceManagerUrl + 'subscriptions/' + $SubscriptionId + '/providers/Microsoft.Compute/locations/' + $VirtualMachine.location + '/vmSizes?api-version=2024-03-01'\r\n\t\t\t$VMSizes = (Invoke-RestMethod -Headers $Header -Method 'Get' -Uri $Uri).value\r\n\r\n\t\t\tforeach ($VMSize in $VMSizes)\r\n            {\r\n\t\t\t\tif (!$VMSizeCores.ContainsKey($VMSize.name))\r\n                {\r\n\t\t\t\t\t$VMSizeCores.Add($VMSize.name, $VMSize.numberOfCores)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif ($PowerState -ieq 'VM running')\r\n        {\r\n\t\t\tif ($SessionHost.properties.status -notin $DesiredRunningStates)\r\n            {\r\n\t\t\t\tWrite-Log -HostPoolName $HostPoolName -Warn -Message 'VM is in running state but session host is not and so it will be ignored (this could be because the VM was just started and has not connected to broker yet)'\r\n\t\t\t}\r\n\t\t\tif (!$SessionHost.properties.allowNewSession)\r\n            {\r\n\t\t\t\tWrite-Log -HostPoolName $HostPoolName -Warn -Message 'VM is in running state but session host is not allowing new sessions and so it will be ignored'\r\n\t\t\t}\r\n\r\n\t\t\tif ($SessionHost.properties.status -in $DesiredRunningStates -and $SessionHost.properties.allowNewSession)\r\n            {\r\n\t\t\t\t++$nRunningVMs\r\n\t\t\t\t$nRunningCores += $VMSizeCores[$VirtualMachine.properties.hardwareProfile.vmSize]\r\n\t\t\t\t$nUserSessionsFromAllRunningVMs += $SessionHost.properties.sessions\r\n\t\t\t}\r\n\t\t}\r\n\t\telse \r\n        {\r\n\t\t\tif ($SessionHost.properties.status -in $DesiredRunningStates)\r\n            {\r\n\t\t\t\tWrite-Log -HostPoolName $HostPoolName -Warn -Message \"VM is not in running state but session host is (this could be because the VM was just stopped and broker doesn't know that yet)\"\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif ($nUserSessionsFromAllRunningVMs -ne $nUserSessions)\r\n    {\r\n\t\tWrite-Log -HostPoolName $HostPoolName -Warn -Message \"Sum of user sessions reported by every running session host ($nUserSessionsFromAllRunningVMs) is not equal to the total number of user sessions reported by the host pool ($nUserSessions)\"\r\n\t}\r\n\r\n\r\n\tif (!$nRunningCores)\r\n    {\r\n\t\t$nRunningCores = 1\r\n\t}\r\n\r\n\tWrite-Log -HostPoolName $HostPoolName -Message \"Number of running session hosts: $nRunningVMs of total $($VMs.Count)\"\r\n\tWrite-Log -HostPoolName $HostPoolName -Message \"Number of user sessions: $nUserSessions of total allowed $($nRunningVMs * $HostPool.properties.maxSessionLimit)\"\r\n\tWrite-Log -HostPoolName $HostPoolName -Message \"Number of user sessions per Core: $($nUserSessions / $nRunningCores), threshold: $SessionThresholdPerCPU\"\r\n\tWrite-Log -HostPoolName $HostPoolName -Message \"Minimum number of running session hosts required: $MinimumNumberOfRDSH\"\r\n\r\n\t# Check if minimum num of running session hosts required is higher than max allowed\r\n\tif ($VMs.Count -le $MinimumNumberOfRDSH)\r\n    {\r\n\t\tWrite-Log -HostPoolName $HostPoolName -Warn -Message 'Minimum number of RDSH is set higher than or equal to total number of session hosts'\r\n\t}\r\n\t#endregion\r\n\r\n\r\n\t#region determine number of session hosts to start/stop if any\r\n\t# Now that we have all the info about the session hosts & their usage, figure how many session hosts to start/stop depending on in/off peak hours and the demand [Ops = operations to perform]\r\n\t$Ops = @{\r\n\t\tnVMsToStart   = 0\r\n\t\tnCoresToStart = 0\r\n\t\tnVMsToStop    = 0\r\n\t}\r\n\r\n\tSet-nVMsToStartOrStop -HostPoolName $HostPoolName -nRunningVMs $nRunningVMs -nRunningCores $nRunningCores -nUserSessions $nUserSessions -MaxUserSessionsPerVM $HostPool.properties.maxSessionLimit -InPeakHours:$InPeakHours -Res $Ops\r\n\t#endregion\r\n\r\n\r\n\t#region start any session hosts if need to\r\n\t# Check if we have any session hosts to start\r\n\tif ($Ops.nVMsToStart -or $Ops.nCoresToStart)\r\n    {\r\n\t\tif ($nRunningVMs -eq $VMs.Count)\r\n        {\r\n\t\t\tWrite-Log -HostPoolName $HostPoolName -Message 'All session hosts are running'\r\n\t\t\tWrite-Log -HostPoolName $HostPoolName -Message 'End'\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t# Object that contains names of session hosts that will be started\r\n\t\t# $StartSessionHostFullNames = @{ }\r\n\t\t# Array that contains jobs of starting the session hosts\r\n\t\t[array]$StartedVMs = @()\r\n\r\n\t\tWrite-Log -HostPoolName $HostPoolName -Message 'Find session hosts that are stopped and allowing new sessions'\r\n\t\tforeach ($SessionHost in $SessionHosts)\r\n        {\r\n\t\t\t$VM = $VMs | Where-Object { $_.id -ieq $SessionHost.properties.resourceId }\r\n\t\t\tif (!$Ops.nVMsToStart -and !$Ops.nCoresToStart)\r\n            {\r\n\t\t\t\t# Done with starting session hosts that needed to be\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t\tif ($VM.properties.instanceView.statuses[1].displayStatus -ieq 'VM running')\r\n            {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\tif ($SessionHost.properties.updateState -ine 'Succeeded')\r\n            {\r\n\t\t\t\tWrite-Log -HostPoolName $HostPoolName -Warn -Message \"Session host '$($VM.name)' may not be healthy\"\r\n\t\t\t}\r\n\r\n\t\t\tif (!$SessionHost.properties.allowNewSession)\r\n            {\r\n\t\t\t\tWrite-Log -HostPoolName $HostPoolName -Warn -Message \"Session host '$($VM.name)' is not allowing new sessions and so it will not be started\"\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tWrite-Log -HostPoolName $HostPoolName -Message \"Start session host '$($VM.name)'\"\r\n\r\n\t\t\t$Uri = $ResourceManagerUrl + $VM.id.TrimStart('/') + '/start?api-version=2023-09-01'\r\n\t\t\tInvoke-RestMethod -Headers $Header -Method 'Post' -Uri $Uri | Out-Null\r\n\t\t\t$StartedVMs += $VM\r\n\t\t\t\t\r\n\t\t\t--$Ops.nVMsToStart\r\n\t\t\tif ($Ops.nVMsToStart -lt 0)\r\n            {\r\n\t\t\t\t$Ops.nVMsToStart = 0\r\n\t\t\t}\r\n\r\n\t\t\t$Ops.nCoresToStart -= $VMSizeCores[$VM.properties.hardwareProfile.vmSize]\r\n\t\t\tif ($Ops.nCoresToStart -lt 0)\r\n            {\r\n\t\t\t\t$Ops.nCoresToStart = 0\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t# Check if there were enough number of session hosts to start\r\n\t\tif ($Ops.nVMsToStart -or $Ops.nCoresToStart)\r\n        {\r\n\t\t\tWrite-Log -HostPoolName $HostPoolName -Warn -Message \"Not enough session hosts to start. Still need to start maximum of either $($Ops.nVMsToStart) VMs or $($Ops.nCoresToStart) cores\"\r\n\t\t}\r\n\r\n\t\t# Wait for session hosts to start\r\n\t\twhile($StartedVMs.Count -gt 0)\r\n\t\t{\r\n\t\t\tforeach($StartedVM in $StartedVMs)\r\n\t\t\t{\r\n\t\t\t\t$Uri = $ResourceManagerUrl + $StartedVM.id.TrimStart('/') + '?api-version=2024-03-01'\r\n\t\t\t\t$VMAgentStatus = (Invoke-RestMethod -Headers $Header -Method 'Get' -Uri $Uri).properties.instanceView.vmAgent\r\n\t\t\t\tif ($VMAgentStatus)\r\n\t\t\t\t{\r\n\t\t\t\t\tWrite-Log -HostPoolName $HostPoolName -Message \"Session host '$($StartedVM.name)' is running\"\r\n\t\t\t\t\t$StartedVMs = $StartedVMs -ne $StartedVM\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tStart-Sleep -Seconds 30\r\n\t\t}\r\n\r\n\t\tWrite-Log -HostPoolName $HostPoolName -Message 'All session hosts have started'\r\n\t\tWrite-Log -HostPoolName $HostPoolName -Message 'End'\r\n\t\treturn\r\n\t}\r\n\t#endregion\r\n\r\n\r\n\t#region stop any session hosts if need to\r\n\tif (!$Ops.nVMsToStop)\r\n    {\r\n\t\tWrite-Log -HostPoolName $HostPoolName -Message 'No need to start/stop any session hosts'\r\n\t\tWrite-Log -HostPoolName $HostPoolName -Message 'End'\r\n\t\treturn\r\n\t}\r\n\r\n\t# Object that contains names of session hosts that will be stopped\r\n\t$VMsToStop = @()\r\n\t[array]$VMsToStopAfterLogOffTimeOut = @()\r\n\r\n\tWrite-Log -HostPoolName $HostPoolName -Message 'Find session hosts that are running and allowing new sessions, sort them by number of user sessions'\r\n\tforeach ($SessionHost in ($SessionHosts | Where-Object { $_.properties.allowNewSession } | Sort-Object { $_.properties.sessions }))\r\n    {\r\n\t\t$VM = $VMs | Where-Object { $_.id -ieq $SessionHost.properties.resourceId }\r\n\t\tif ($VM.properties.instanceView.statuses[1].displayStatus -ieq 'VM running')\r\n\t\t{\r\n\t\t\tif (!$Ops.nVMsToStop)\r\n\t\t\t{\r\n\t\t\t\t# Done with stopping session hosts that needed to be\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif ($SessionHost.properties.sessions -gt 0 -and !$LimitSecondsToForceLogOffUser)\r\n\t\t\t{\r\n\t\t\t\tWrite-Log -HostPoolName $HostPoolName -Warn -Message \"Session host '$($VM.name)' has $($SessionHost.properties.sessions) sessions but limit seconds to force log off user is set to 0, so will not stop any more session hosts (https://aka.ms/wvdscale#how-the-scaling-tool-works)\"\r\n\t\t\t\t# Note: why break ? Because the list this loop iterates through is sorted by number of sessions, if it hits this, the rest of items in the loop will also hit this\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tTryUpdateSessionHostDrainMode -AllowNewSession $false -Header $Header -HostPoolName $HostPoolName -HostPoolResourceGroupName $HostPoolResourceGroupName -ResourceManagerUrl $ResourceManagerUrl -SessionHostName $VM.name -SubscriptionId $SubscriptionId\r\n\r\n\t\t\t# Note: check if there were new user sessions since session host info was 1st fetched\r\n\t\t\tif ($SessionHost.properties.sessions -gt 0 -and !$LimitSecondsToForceLogOffUser)\r\n\t\t\t{\r\n\t\t\t\tWrite-Log -HostPoolName $HostPoolName -Warn -Message \"Session host '$($VM.name)' has $($SessionHost.properties.sessions) sessions but limit seconds to force log off user is set to 0, so will not stop any more session hosts (https://aka.ms/wvdscale#how-the-scaling-tool-works)\"\r\n\t\t\t\tTryUpdateSessionHostDrainMode -AllowNewSession $true -Header $Header -HostPoolName $HostPoolName -HostPoolResourceGroupName $HostPoolResourceGroupName -ResourceManagerUrl $ResourceManagerUrl -SessionHostName $VM.name -SubscriptionId $SubscriptionId \r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif ($SessionHost.properties.sessions -gt 0)\r\n\t\t\t{\r\n\t\t\t\tWrite-Log -HostPoolName $HostPoolName -Message \"Get all user sessions from session host '$($VM.name)'\"\r\n\t\t\t\ttry \r\n\t\t\t\t{\r\n\t\t\t\t\t$Uri = $ResourceManagerUrl + 'subscriptions/' + $SubscriptionId  + '/resourceGroups/' + $HostPoolResourceGroupName + '/providers/Microsoft.DesktopVirtualization/hostPools/' + $HostPoolName + '/sessionHosts/' + $VM.name + '/userSessions?api-version=2022-02-10-preview'\r\n\t\t\t\t\t$UserSessions = Invoke-RestMethod -Headers $Header -Method 'Get' -Uri $Uri\r\n\t\t\t\t}\r\n\t\t\t\tcatch\r\n\t\t\t\t{\r\n\t\t\t\t\tWrite-Log -HostPoolName $HostPoolName -Warn -Message \"Failed to retrieve user sessions of session host '$($VM.name)': $($PSItem | Format-List -Force | Out-String)\"\r\n\t\t\t\t}\r\n\r\n\t\t\t\tWrite-Log -HostPoolName $HostPoolName -Message \"Send log off message to active user sessions on session host: '$($VM.name)'\"\r\n\t\t\t\tforeach ($UserSession in $UserSessions)\r\n\t\t\t\t{\r\n\t\t\t\t\tif($UserSession.properties.sessionState -ine 'Active')\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t[string]$SessionID = $UserSession.name.Split('/')[-1]\r\n\t\t\t\t\t[string]$User = $UserSession.properties.activeDirectoryUserName\r\n\t\t\t\t\t\r\n\t\t\t\t\ttry \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tWrite-Log -HostPoolName $HostPoolName -Message \"Send a log off message to user: '$User', session ID: $SessionID\"\r\n\r\n\t\t\t\t\t\t$Uri = $ResourceManagerUrl + 'subscriptions/' + $SubscriptionId  + '/resourceGroups/' + $HostPoolResourceGroupName + '/providers/Microsoft.DesktopVirtualization/hostPools/' + $HostPoolName + '/sessionHosts/' + $VM.name + '/userSessions/' + $SessionID + '/sendMessage?api-version=2022-02-10-preview'\r\n\t\t\t\t\t\tInvoke-RestMethod -Headers $Header -Method 'Post' -Uri $Uri -Body (@{ 'messageTitle' = $LogOffMessageTitle; 'messageBody' = \"$LogOffMessageBody You will be logged off in $LimitSecondsToForceLogOffUser seconds\" } | ConvertTo-Json) | Out-Null\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcatch \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tWrite-Log -HostPoolName $HostPoolName -Warn -Message \"Failed to send a log off message to user: '$User', session ID: $SessionID $($PSItem | Format-List -Force | Out-String)\"\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t$VMsToStopAfterLogOffTimeOut += $VM\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tWrite-Log -HostPoolName $HostPoolName -Message \"Stop session host '$($VM.name)'\"\r\n\t\t\t\t$Uri = $ResourceManagerUrl + $VM.id.TrimStart('/') + '/deallocate?api-version=2023-09-01'\r\n\t\t\t\tInvoke-RestMethod -Headers $Header -Method 'Post' -Uri $Uri | Out-Null\r\n\t\t\t\t$VMsToStop += $VM\r\n\t\t\t}\r\n\r\n\t\t\t--$Ops.nVMsToStop\r\n\t\t\tif ($Ops.nVMsToStop -lt 0) {\r\n\t\t\t\t$Ops.nVMsToStop = 0\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif ($VMsToStopAfterLogOffTimeOut)\r\n    {\r\n\t\tWrite-Log -HostPoolName $HostPoolName -Message \"Wait $LimitSecondsToForceLogOffUser seconds for users to log off\"\r\n\r\n\t\tStart-Sleep -Seconds $LimitSecondsToForceLogOffUser\r\n\r\n\t\tWrite-Log -HostPoolName $HostPoolName -Message \"Force log off users and stop remaining $($VMsToStopAfterLogOffTimeOut.Count) session hosts\"\r\n\t\tforeach ($VM in $VMsToStopAfterLogOffTimeOut)\r\n        {\r\n\t\t\t$SessionHost = $SessionHosts | Where-Object { $_.properties.resourceId -ieq $VM.id }\r\n\t\t\tWrite-Log -HostPoolName $HostPoolName -Message \"Force log off $($SessionHost.sessions) users on session host: '$($VM.name)'\"\r\n\t\t\t$VM.UserSessions | TryForceLogOffUser -Header $Header -HostPoolName $HostPoolName -HostPoolResourceGroupName $HostPoolResourceGroupName -ResourceManagerUrl $ResourceManagerUrl -SubscriptionId $SubscriptionId\r\n\t\t\t\r\n\t\t\tWrite-Log -HostPoolName $HostPoolName -Message \"Stop session host '$($VM.name)'\"\r\n\t\t\t$Uri = $ResourceManagerUrl + $VM.id.TrimStart('/') + '/deallocate?api-version=2023-09-01'\r\n\t\t\tInvoke-RestMethod -Headers $Header -Method 'Post' -Uri $Uri | Out-Null\r\n\t\t\t$VMsToStop += $VM\r\n\t\t}\r\n\t}\r\n\r\n\t# Check if there were enough number of session hosts to stop\r\n\tif ($Ops.nVMsToStop)\r\n    {\r\n\t\tWrite-Log -HostPoolName $HostPoolName -Warn -Message \"Not enough session hosts to stop. Still need to stop $($Ops.nVMsToStop) VMs\"\r\n\t}\r\n\r\n\t# Wait for the session hosts to stop / deallocate\r\n\tWrite-Log -HostPoolName $HostPoolName -Message \"Wait for session hosts to stop / deallocate\"\r\n\twhile($VMsToStop.Count -gt 0)\r\n\t{\r\n\t\tforeach($VMToStop in $VMsToStop)\r\n\t\t{\r\n\t\t\t$Uri = $ResourceManagerUrl + $VMToStop.id.TrimStart('/') + '?$expand=instanceView&api-version=2024-03-01'\r\n\t\t\t$VMPowerState = (Invoke-RestMethod -Headers $Header -Method 'Get' -Uri $Uri).properties.instanceView.statuses[1].displayStatus\r\n\t\t\tif ($VMPowerState -eq 'VM deallocated')\r\n\t\t\t{\r\n\t\t\t\tWrite-Log -HostPoolName $HostPoolName -Message \"Session host '$($VMToStop.name)' is stopping\"\r\n\t\t\t\t$SessionHost = $SessionHosts | Where-Object { $_.properties.resourceId -ieq $VMToStop.id }\r\n\t\t\t\tTryResetSessionHostDrainModeAndUserSessions -Header $Header -HostPoolName $HostPoolName -HostPoolResourceGroupName $HostPoolResourceGroupName -ResourceManagerUrl $ResourceManagerUrl -SessionHostName $VMToStop.name -SessionHostSessions $SessionHost.properties.sessions -SubscriptionId $SubscriptionId\r\n\t\t\t\t$VMsToStop = $VMsToStop -ne $VMToStop\r\n\t\t\t}\r\n\t\t}\r\n\t\tStart-Sleep -Seconds 30\r\n\t}\r\n\r\n\tWrite-Log -HostPoolName $HostPoolName -Message 'All required session hosts have stopped.'\r\n\tWrite-Log -HostPoolName $HostPoolName -Message 'End'\r\n\treturn\r\n\t#endregion\r\n}\r\ncatch \r\n{\r\n\t$ErrContainer = $PSItem\r\n\t# $ErrContainer = $_\r\n\r\n\t[string]$ErrMsg = $ErrContainer | Format-List -Force | Out-String\r\n\t$ErrMsg += \"Version: $Version`n\"\r\n\r\n\tif (Get-Command 'Write-Log' -ErrorAction:SilentlyContinue)\r\n    {\r\n\t\tWrite-Log -HostPoolName $HostPoolName -Err -Message $ErrMsg -ErrorAction:Continue\r\n\t}\r\n\telse\r\n    {\r\n\t\tWrite-Error $ErrMsg -ErrorAction:Continue\r\n\t}\r\n\r\n\tthrow [System.Exception]::new($ErrMsg, $ErrContainer.Exception)\r\n}",
    "$fxv#4": "# Authentication is provided in the script",
    "applicationInsightsName": "[replace(variables('namingConvention'), 'resourceType', variables('resourceTypes').applicationInsights)]",
    "appServicePlanName": "[replace(variables('namingConvention'), 'resourceType', variables('resourceTypes').appServicePlans)]",
    "diagnosticsSettingName": "[replace(variables('namingConvention'), 'resourceType', format('{0}-subType', variables('resourceTypes').diagnosticSettings))]",
    "fileShareName": "function-app",
    "functionAppName": "[replace(variables('namingConvention'), 'resourceType', variables('resourceTypes').functionApps)]",
    "functionName": "[replace(variables('namingConvention'), 'resourceType', variables('resourceTypes').functions)]",
    "keyVaultName": "[replace(replace(variables('namingConvention'), 'resourceType', variables('resourceTypes').keyVaults), '-', '')]",
    "locations": "[variables('$fxv#0')[environment().name]]",
    "namingConvention": "[format('{0}-resourceType-scaling-avd-{1}-{2}', parameters('identifier'), parameters('environmentAbbreviation'), variables('locations')[parameters('location')].abbreviation)]",
    "networkInterfaceName": "[replace(variables('namingConvention'), 'resourceType', format('{0}-subType', variables('resourceTypes').networkInterfaces))]",
    "privateEndpointName": "[replace(variables('namingConvention'), 'resourceType', format('{0}-subType', variables('resourceTypes').privateEndpoints))]",
    "privateLinkScopeResourceGroupName": "[if(empty(parameters('logAnalyticsWorkspaceResourceId')), resourceGroup().name, split(parameters('privateLinkScopeResourceId'), '/')[4])]",
    "privateLinkScopeSubscriptionId": "[if(empty(parameters('logAnalyticsWorkspaceResourceId')), subscription().subscriptionId, split(parameters('privateLinkScopeResourceId'), '/')[2])]",
    "resourceTypes": "[variables('$fxv#1')]",
    "roleAssignments": "[if(equals(parameters('hostPoolResourceGroupName'), parameters('sessionHostsResourceGroupName')), createArray(parameters('hostPoolResourceGroupName')), createArray(parameters('hostPoolResourceGroupName'), parameters('sessionHostsResourceGroupName')))]",
    "storageAccountName": "[replace(replace(variables('namingConvention'), 'resourceType', variables('resourceTypes').storageAccounts), '-', '')]",
    "storagePrivateDnsZoneResourceIds": [
      "[parameters('azureBlobsPrivateDnsZoneResourceId')]",
      "[parameters('azureFilesPrivateDnsZoneResourceId')]",
      "[parameters('azureQueuesPrivateDnsZoneResourceId')]",
      "[parameters('azureTablesPrivateDnsZoneResourceId')]"
    ],
    "storageSubResources": [
      "blob",
      "file",
      "queue",
      "table"
    ],
    "userAssignedIdentityName": "[replace(variables('namingConvention'), 'resourceType', variables('resourceTypes').userAssignedIdentities)]"
  },
  "resources": [
    {
      "type": "Microsoft.ManagedIdentity/userAssignedIdentities",
      "apiVersion": "2023-01-31",
      "name": "[variables('userAssignedIdentityName')]",
      "location": "[parameters('location')]",
      "tags": "[if(contains(parameters('tags'), 'Microsoft.ManagedIdentity/userAssignedIdentities'), parameters('tags')['Microsoft.ManagedIdentity/userAssignedIdentities'], createObject())]"
    },
    {
      "type": "Microsoft.Authorization/roleAssignments",
      "apiVersion": "2022-04-01",
      "name": "[guid(variables('userAssignedIdentityName'), 'e147488a-f6f5-4113-8e2d-b22465e65bf6', resourceGroup().id)]",
      "properties": {
        "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', 'e147488a-f6f5-4113-8e2d-b22465e65bf6')]",
        "principalId": "[reference(resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', variables('userAssignedIdentityName')), '2023-01-31').principalId]",
        "principalType": "ServicePrincipal"
      },
      "dependsOn": [
        "[resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', variables('userAssignedIdentityName'))]"
      ]
    },
    {
      "type": "Microsoft.KeyVault/vaults",
      "apiVersion": "2022-07-01",
      "name": "[variables('keyVaultName')]",
      "location": "[parameters('location')]",
      "tags": "[if(contains(parameters('tags'), 'Microsoft.KeyVault/vaults'), parameters('tags')['Microsoft.KeyVault/vaults'], createObject())]",
      "properties": {
        "enabledForDeployment": false,
        "enabledForDiskEncryption": false,
        "enabledForTemplateDeployment": false,
        "enablePurgeProtection": true,
        "enableRbacAuthorization": true,
        "enableSoftDelete": true,
        "networkAcls": {
          "bypass": "AzureServices",
          "defaultAction": "Deny",
          "ipRules": [],
          "virtualNetworkRules": []
        },
        "publicNetworkAccess": "Disabled",
        "sku": {
          "family": "A",
          "name": "standard"
        },
        "softDeleteRetentionInDays": "[if(or(equals(parameters('environmentAbbreviation'), 'dev'), equals(parameters('environmentAbbreviation'), 'test')), 7, 90)]",
        "tenantId": "[subscription().tenantId]"
      }
    },
    {
      "type": "Microsoft.Network/privateEndpoints",
      "apiVersion": "2023-04-01",
      "name": "[replace(variables('privateEndpointName'), 'subType', 'kv')]",
      "location": "[parameters('location')]",
      "tags": "[if(contains(parameters('tags'), 'Microsoft.Network/privateEndpoints'), parameters('tags')['Microsoft.Network/privateEndpoints'], createObject())]",
      "properties": {
        "customNetworkInterfaceName": "[replace(variables('networkInterfaceName'), 'subType', 'kv')]",
        "privateLinkServiceConnections": [
          {
            "name": "[replace(variables('privateEndpointName'), 'subType', 'kv')]",
            "properties": {
              "privateLinkServiceId": "[resourceId('Microsoft.KeyVault/vaults', variables('keyVaultName'))]",
              "groupIds": [
                "vault"
              ]
            }
          }
        ],
        "subnet": {
          "id": "[parameters('privateEndpointsSubnetResourceId')]"
        }
      },
      "dependsOn": [
        "[resourceId('Microsoft.KeyVault/vaults', variables('keyVaultName'))]"
      ]
    },
    {
      "type": "Microsoft.Network/privateEndpoints/privateDnsZoneGroups",
      "apiVersion": "2021-08-01",
      "name": "[format('{0}/{1}', replace(variables('privateEndpointName'), 'subType', 'kv'), variables('keyVaultName'))]",
      "properties": {
        "privateDnsZoneConfigs": [
          {
            "name": "ipconfig1",
            "properties": {
              "privateDnsZoneId": "[parameters('keyVaultPrivateDnsZoneResourceId')]"
            }
          }
        ]
      },
      "dependsOn": [
        "[resourceId('Microsoft.Network/privateEndpoints', replace(variables('privateEndpointName'), 'subType', 'kv'))]"
      ]
    },
    {
      "type": "Microsoft.KeyVault/vaults/keys",
      "apiVersion": "2022-07-01",
      "name": "[format('{0}/{1}', variables('keyVaultName'), 'StorageEncryptionKey')]",
      "properties": {
        "attributes": {
          "enabled": true
        },
        "keySize": 4096,
        "kty": "RSA",
        "rotationPolicy": {
          "attributes": {
            "expiryTime": "[format('P{0}D', string(parameters('keyExpirationInDays')))]"
          },
          "lifetimeActions": [
            {
              "action": {
                "type": "Notify"
              },
              "trigger": {
                "timeBeforeExpiry": "P10D"
              }
            },
            {
              "action": {
                "type": "Rotate"
              },
              "trigger": {
                "timeAfterCreate": "[format('P{0}D', string(sub(parameters('keyExpirationInDays'), 7)))]"
              }
            }
          ]
        }
      },
      "dependsOn": [
        "[resourceId('Microsoft.KeyVault/vaults', variables('keyVaultName'))]"
      ]
    },
    {
      "type": "Microsoft.Storage/storageAccounts",
      "apiVersion": "2022-09-01",
      "name": "[variables('storageAccountName')]",
      "location": "[parameters('location')]",
      "tags": "[if(contains(parameters('tags'), 'Microsoft.Storage/storageAccounts'), parameters('tags')['Microsoft.Storage/storageAccounts'], createObject())]",
      "sku": {
        "name": "Standard_LRS"
      },
      "kind": "StorageV2",
      "identity": {
        "type": "UserAssigned",
        "userAssignedIdentities": {
          "[format('{0}', resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', variables('userAssignedIdentityName')))]": {}
        }
      },
      "properties": {
        "accessTier": "Hot",
        "allowBlobPublicAccess": false,
        "allowCrossTenantReplication": false,
        "allowedCopyScope": "PrivateLink",
        "allowSharedKeyAccess": true,
        "azureFilesIdentityBasedAuthentication": {
          "directoryServiceOptions": "None"
        },
        "defaultToOAuthAuthentication": false,
        "dnsEndpointType": "Standard",
        "encryption": {
          "identity": {
            "userAssignedIdentity": "[resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', variables('userAssignedIdentityName'))]"
          },
          "requireInfrastructureEncryption": true,
          "keyvaultproperties": {
            "keyvaulturi": "[reference(resourceId('Microsoft.KeyVault/vaults', variables('keyVaultName')), '2022-07-01').vaultUri]",
            "keyname": "StorageEncryptionKey"
          },
          "services": {
            "file": {
              "keyType": "Account",
              "enabled": true
            },
            "table": {
              "keyType": "Account",
              "enabled": true
            },
            "queue": {
              "keyType": "Account",
              "enabled": true
            },
            "blob": {
              "keyType": "Account",
              "enabled": true
            }
          },
          "keySource": "Microsoft.KeyVault"
        },
        "largeFileSharesState": "Disabled",
        "minimumTlsVersion": "TLS1_2",
        "networkAcls": {
          "bypass": "AzureServices",
          "virtualNetworkRules": [],
          "ipRules": [],
          "defaultAction": "Deny"
        },
        "publicNetworkAccess": "Disabled",
        "supportsHttpsTrafficOnly": true
      },
      "dependsOn": [
        "[resourceId('Microsoft.KeyVault/vaults/keys', variables('keyVaultName'), 'StorageEncryptionKey')]",
        "[resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', variables('userAssignedIdentityName'))]",
        "[resourceId('Microsoft.KeyVault/vaults', variables('keyVaultName'))]"
      ]
    },
    {
      "type": "Microsoft.Storage/storageAccounts/blobServices",
      "apiVersion": "2021-09-01",
      "name": "[format('{0}/{1}', variables('storageAccountName'), 'default')]",
      "dependsOn": [
        "[resourceId('Microsoft.Storage/storageAccounts', variables('storageAccountName'))]"
      ]
    },
    {
      "type": "Microsoft.Storage/storageAccounts/fileServices",
      "apiVersion": "2022-09-01",
      "name": "[format('{0}/{1}', variables('storageAccountName'), 'default')]",
      "properties": {
        "protocolSettings": {
          "smb": {
            "versions": "SMB3.1.1;",
            "authenticationMethods": "NTLMv2;",
            "channelEncryption": "AES-128-GCM;AES-256-GCM;"
          }
        },
        "shareDeleteRetentionPolicy": {
          "enabled": false
        }
      },
      "dependsOn": [
        "[resourceId('Microsoft.Storage/storageAccounts', variables('storageAccountName'))]"
      ]
    },
    {
      "type": "Microsoft.Storage/storageAccounts/fileServices/shares",
      "apiVersion": "2022-09-01",
      "name": "[format('{0}/{1}/{2}', variables('storageAccountName'), 'default', variables('fileShareName'))]",
      "properties": {
        "accessTier": "TransactionOptimized",
        "shareQuota": 5120,
        "enabledProtocols": "SMB"
      },
      "dependsOn": [
        "[resourceId('Microsoft.Storage/storageAccounts/fileServices', variables('storageAccountName'), 'default')]"
      ]
    },
    {
      "copy": {
        "name": "privateEndpoints_storage",
        "count": "[length(variables('storageSubResources'))]"
      },
      "type": "Microsoft.Network/privateEndpoints",
      "apiVersion": "2023-04-01",
      "name": "[replace(variables('privateEndpointName'), 'subType', format('{0}-st', variables('storageSubResources')[copyIndex()]))]",
      "location": "[parameters('location')]",
      "tags": "[if(contains(parameters('tags'), 'Microsoft.Network/privateEndpoints'), parameters('tags')['Microsoft.Network/privateEndpoints'], createObject())]",
      "properties": {
        "customNetworkInterfaceName": "[replace(variables('networkInterfaceName'), 'subType', format('{0}-st', variables('storageSubResources')[copyIndex()]))]",
        "privateLinkServiceConnections": [
          {
            "name": "[replace(variables('privateEndpointName'), 'subType', format('{0}-st', variables('storageSubResources')[copyIndex()]))]",
            "properties": {
              "privateLinkServiceId": "[resourceId('Microsoft.Storage/storageAccounts', variables('storageAccountName'))]",
              "groupIds": [
                "[variables('storageSubResources')[copyIndex()]]"
              ]
            }
          }
        ],
        "subnet": {
          "id": "[parameters('privateEndpointsSubnetResourceId')]"
        }
      },
      "dependsOn": [
        "[resourceId('Microsoft.Storage/storageAccounts', variables('storageAccountName'))]"
      ]
    },
    {
      "copy": {
        "name": "privateDnsZoneGroups_storage",
        "count": "[length(variables('storageSubResources'))]"
      },
      "type": "Microsoft.Network/privateEndpoints/privateDnsZoneGroups",
      "apiVersion": "2021-08-01",
      "name": "[format('{0}/{1}', replace(variables('privateEndpointName'), 'subType', format('{0}-st', variables('storageSubResources')[copyIndex()])), variables('storageAccountName'))]",
      "properties": {
        "privateDnsZoneConfigs": [
          {
            "name": "ipconfig1",
            "properties": {
              "privateDnsZoneId": "[variables('storagePrivateDnsZoneResourceIds')[copyIndex()]]"
            }
          }
        ]
      },
      "dependsOn": [
        "[resourceId('Microsoft.Network/privateEndpoints', replace(variables('privateEndpointName'), 'subType', format('{0}-st', variables('storageSubResources')[copyIndex()])))]",
        "[resourceId('Microsoft.Storage/storageAccounts', variables('storageAccountName'))]"
      ]
    },
    {
      "condition": "[not(empty(parameters('logAnalyticsWorkspaceResourceId')))]",
      "type": "Microsoft.Insights/diagnosticSettings",
      "apiVersion": "2017-05-01-preview",
      "scope": "[format('Microsoft.Storage/storageAccounts/{0}/blobServices/{1}', variables('storageAccountName'), 'default')]",
      "name": "[replace(variables('diagnosticsSettingName'), 'subType', 'blob-st')]",
      "properties": {
        "logs": [
          {
            "category": "StorageWrite",
            "enabled": true
          }
        ],
        "metrics": [
          {
            "category": "Transaction",
            "enabled": true
          }
        ],
        "workspaceId": "[parameters('logAnalyticsWorkspaceResourceId')]"
      },
      "dependsOn": [
        "[resourceId('Microsoft.Storage/storageAccounts/blobServices', variables('storageAccountName'), 'default')]"
      ]
    },
    {
      "type": "Microsoft.Insights/components",
      "apiVersion": "2020-02-02",
      "name": "[variables('applicationInsightsName')]",
      "location": "[parameters('location')]",
      "tags": "[if(contains(parameters('tags'), 'Microsoft.Insights/components'), parameters('tags')['Microsoft.Insights/components'], createObject())]",
      "properties": {
        "Application_Type": "web"
      },
      "kind": "web"
    },
    {
      "type": "Microsoft.Web/serverfarms",
      "apiVersion": "2023-01-01",
      "name": "[variables('appServicePlanName')]",
      "location": "[parameters('location')]",
      "tags": "[if(contains(parameters('tags'), 'Microsoft.Web/serverfarms'), parameters('tags')['Microsoft.Web/serverfarms'], createObject())]",
      "sku": {
        "tier": "ElasticPremium",
        "name": "EP1"
      },
      "kind": "functionapp",
      "properties": {
        "targetWorkerSizeId": 3,
        "targetWorkerCount": 1,
        "maximumElasticWorkerCount": 20,
        "zoneRedundant": false
      },
      "dependsOn": [
        "privateDnsZoneGroups_storage",
        "privateEndpoints_storage"
      ]
    },
    {
      "type": "Microsoft.Web/sites",
      "apiVersion": "2023-01-01",
      "name": "[variables('functionAppName')]",
      "location": "[parameters('location')]",
      "tags": "[if(contains(parameters('tags'), 'Microsoft.Web/sites'), parameters('tags')['Microsoft.Web/sites'], createObject())]",
      "kind": "functionapp",
      "identity": {
        "type": "SystemAssigned"
      },
      "properties": {
        "clientAffinityEnabled": false,
        "httpsOnly": true,
        "publicNetworkAccess": "Disabled",
        "serverFarmId": "[resourceId('Microsoft.Web/serverfarms', variables('appServicePlanName'))]",
        "siteConfig": {
          "appSettings": [
            {
              "name": "FUNCTIONS_EXTENSION_VERSION",
              "value": "~4"
            },
            {
              "name": "FUNCTIONS_WORKER_RUNTIME",
              "value": "powershell"
            },
            {
              "name": "APPLICATIONINSIGHTS_CONNECTION_STRING",
              "value": "[reference(resourceId('Microsoft.Insights/components', variables('applicationInsightsName')), '2020-02-02').ConnectionString]"
            },
            {
              "name": "AzureWebJobsStorage",
              "value": "[format('DefaultEndpointsProtocol=https;AccountName={0};AccountKey={1};EndpointSuffix={2}', variables('storageAccountName'), listKeys(resourceId('Microsoft.Storage/storageAccounts', variables('storageAccountName')), '2019-06-01').keys[0].value, environment().suffixes.storage)]"
            },
            {
              "name": "WEBSITE_CONTENTAZUREFILECONNECTIONSTRING",
              "value": "[format('DefaultEndpointsProtocol=https;AccountName={0};AccountKey={1};EndpointSuffix={2}', variables('storageAccountName'), listKeys(resourceId('Microsoft.Storage/storageAccounts', variables('storageAccountName')), '2019-06-01').keys[0].value, environment().suffixes.storage)]"
            },
            {
              "name": "WEBSITE_CONTENTSHARE",
              "value": "[variables('fileShareName')]"
            },
            {
              "name": "BeginPeakTime",
              "value": "[parameters('beginPeakTime')]"
            },
            {
              "name": "EndPeakTime",
              "value": "[parameters('endPeakTime')]"
            },
            {
              "name": "EnvironmentName",
              "value": "[environment().name]"
            },
            {
              "name": "HostPoolName",
              "value": "[parameters('hostPoolName')]"
            },
            {
              "name": "HostPoolResourceGroupName",
              "value": "[parameters('hostPoolResourceGroupName')]"
            },
            {
              "name": "LimitSecondsToForceLogOffUser",
              "value": "[parameters('limitSecondsToForceLogOffUser')]"
            },
            {
              "name": "LogOffMessageBody",
              "value": "This session is about to be logged off. Please save your work."
            },
            {
              "name": "LogOffMessageTitle",
              "value": "Session Log Off"
            },
            {
              "name": "MaintenanceTagName",
              "value": "Maintenance"
            },
            {
              "name": "MinimumNumberOfRDSH",
              "value": "[parameters('minimumNumberOfRdsh')]"
            },
            {
              "name": "ResourceManagerUrl",
              "value": "[if(endsWith(environment().resourceManager, '/'), environment().resourceManager, format('{0}/', environment().resourceManager))]"
            },
            {
              "name": "SessionThresholdPerCPU",
              "value": "[parameters('sessionThresholdPerCPU')]"
            },
            {
              "name": "SubscriptionId",
              "value": "[subscription().subscriptionId]"
            },
            {
              "name": "TenantId",
              "value": "[subscription().tenantId]"
            },
            {
              "name": "TimeDifference",
              "value": "[variables('locations')[parameters('location')].timeDifference]"
            }
          ],
          "cors": {
            "allowedOrigins": [
              "[environment().portal]"
            ]
          },
          "ftpsState": "FtpsOnly",
          "netFrameworkVersion": "v6.0",
          "powerShellVersion": "7.2",
          "use32BitWorkerProcess": false
        },
        "virtualNetworkSubnetId": "[parameters('delegatedSubnetResourceId')]",
        "vnetContentShareEnabled": true,
        "vnetRouteAllEnabled": true
      },
      "dependsOn": [
        "[resourceId('Microsoft.Insights/components', variables('applicationInsightsName'))]",
        "[resourceId('Microsoft.Web/serverfarms', variables('appServicePlanName'))]",
        "[resourceId('Microsoft.Storage/storageAccounts', variables('storageAccountName'))]"
      ]
    },
    {
      "type": "Microsoft.Network/privateEndpoints",
      "apiVersion": "2023-04-01",
      "name": "[replace(variables('privateEndpointName'), 'subType', 'fa')]",
      "location": "[parameters('location')]",
      "properties": {
        "customNetworkInterfaceName": "[replace(variables('networkInterfaceName'), 'subType', 'fa')]",
        "privateLinkServiceConnections": [
          {
            "name": "[replace(variables('privateEndpointName'), 'subType', 'fa')]",
            "properties": {
              "privateLinkServiceId": "[resourceId('Microsoft.Web/sites', variables('functionAppName'))]",
              "groupIds": [
                "sites"
              ]
            }
          }
        ],
        "subnet": {
          "id": "[parameters('privateEndpointsSubnetResourceId')]"
        }
      },
      "dependsOn": [
        "[resourceId('Microsoft.Web/sites', variables('functionAppName'))]"
      ]
    },
    {
      "type": "Microsoft.Network/privateEndpoints/privateDnsZoneGroups",
      "apiVersion": "2021-08-01",
      "name": "[format('{0}/{1}', replace(variables('privateEndpointName'), 'subType', 'fa'), 'default')]",
      "properties": {
        "privateDnsZoneConfigs": [
          {
            "name": "ipconfig1",
            "properties": {
              "privateDnsZoneId": "[parameters('azureFunctionsPrivateDnsZoneResourceId')]"
            }
          }
        ]
      },
      "dependsOn": [
        "[resourceId('Microsoft.Network/privateEndpoints', replace(variables('privateEndpointName'), 'subType', 'fa'))]"
      ]
    },
    {
      "type": "Microsoft.Web/sites/functions",
      "apiVersion": "2020-12-01",
      "name": "[format('{0}/{1}', variables('functionAppName'), variables('functionName'))]",
      "properties": {
        "config": {
          "disabled": false,
          "bindings": [
            {
              "name": "Timer",
              "type": "timerTrigger",
              "direction": "in",
              "schedule": "0 */15 * * * *"
            }
          ]
        },
        "files": {
          "requirements.psd1": "[variables('$fxv#2')]",
          "run.ps1": "[variables('$fxv#3')]",
          "../profile.ps1": "[variables('$fxv#4')]"
        }
      },
      "dependsOn": [
        "[resourceId('Microsoft.Web/sites', variables('functionAppName'))]",
        "[resourceId('Microsoft.Network/privateEndpoints/privateDnsZoneGroups', replace(variables('privateEndpointName'), 'subType', 'fa'), 'default')]",
        "[resourceId('Microsoft.Network/privateEndpoints', replace(variables('privateEndpointName'), 'subType', 'fa'))]"
      ]
    },
    {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "[format('PrivateLinkScope_{0}', parameters('timestamp'))]",
      "subscriptionId": "[variables('privateLinkScopeSubscriptionId')]",
      "resourceGroup": "[variables('privateLinkScopeResourceGroupName')]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "applicationInsightsName": {
            "value": "[variables('applicationInsightsName')]"
          },
          "applicationInsightsResourceId": {
            "value": "[resourceId('Microsoft.Insights/components', variables('applicationInsightsName'))]"
          },
          "privateLinkScopeResourceId": {
            "value": "[parameters('privateLinkScopeResourceId')]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.27.1.19265",
              "templateHash": "10644124455373168550"
            }
          },
          "parameters": {
            "applicationInsightsName": {
              "type": "string"
            },
            "applicationInsightsResourceId": {
              "type": "string"
            },
            "privateLinkScopeResourceId": {
              "type": "string"
            }
          },
          "resources": [
            {
              "type": "Microsoft.Insights/privateLinkScopes/scopedResources",
              "apiVersion": "2021-09-01",
              "name": "[format('{0}/{1}', split(parameters('privateLinkScopeResourceId'), '/')[8], parameters('applicationInsightsName'))]",
              "properties": {
                "linkedResourceId": "[parameters('applicationInsightsResourceId')]"
              }
            }
          ]
        }
      },
      "dependsOn": [
        "[resourceId('Microsoft.Insights/components', variables('applicationInsightsName'))]"
      ]
    },
    {
      "copy": {
        "name": "roleAssignments_ResourceGroups",
        "count": "[length(range(0, length(variables('roleAssignments'))))]"
      },
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "[format('RoleAssignment_{0}_{1}', variables('roleAssignments')[range(0, length(variables('roleAssignments')))[copyIndex()]], parameters('timestamp'))]",
      "resourceGroup": "[variables('roleAssignments')[range(0, length(variables('roleAssignments')))[copyIndex()]]]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "PrincipalId": {
            "value": "[reference(resourceId('Microsoft.Web/sites', variables('functionAppName')), '2023-01-01', 'full').identity.principalId]"
          },
          "RoleDefinitionId": {
            "value": "[resourceId('Microsoft.Authorization/roleDefinitions', '40c5ff49-9181-41f8-ae61-143b0e78555e')]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.27.1.19265",
              "templateHash": "646536421399396019"
            }
          },
          "parameters": {
            "PrincipalId": {
              "type": "string"
            },
            "RoleDefinitionId": {
              "type": "string"
            }
          },
          "resources": [
            {
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "name": "[guid(parameters('PrincipalId'), parameters('RoleDefinitionId'), resourceGroup().id)]",
              "properties": {
                "roleDefinitionId": "[parameters('RoleDefinitionId')]",
                "principalId": "[parameters('PrincipalId')]",
                "principalType": "ServicePrincipal"
              }
            }
          ]
        }
      },
      "dependsOn": [
        "[resourceId('Microsoft.Web/sites', variables('functionAppName'))]"
      ]
    }
  ]
}